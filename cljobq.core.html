<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>cljobq.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Cljobq</span> <span class="project-version">0.1.2</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cljobq</span></div></div></li><li class="depth-2 branch current"><a href="cljobq.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="cljobq.cron.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cron</span></div></a></li><li class="depth-2 branch"><a href="cljobq.job.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>job</span></div></a></li><li class="depth-2 branch"><a href="cljobq.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2"><a href="cljobq.worker.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>worker</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="cljobq.core.html#var-db-migrate.21"><div class="inner"><span>db-migrate!</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-delete-job"><div class="inner"><span>delete-job</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-delete-queue-jobs"><div class="inner"><span>delete-queue-jobs</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-enqueue"><div class="inner"><span>enqueue</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-global-ctx*"><div class="inner"><span>global-ctx*</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-list-failed-jobs"><div class="inner"><span>list-failed-jobs</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-list-jobs"><div class="inner"><span>list-jobs</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-list-recurring-jobs"><div class="inner"><span>list-recurring-jobs</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-make-context"><div class="inner"><span>make-context</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-set-context.21"><div class="inner"><span>set-context!</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-start"><div class="inner"><span>start</span></div></a></li><li class="depth-1"><a href="cljobq.core.html#var-stop"><div class="inner"><span>stop</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">cljobq.core</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-db-migrate.21"><h3>db-migrate!</h3><div class="usage"><code>(db-migrate!)</code><code>(db-migrate! {:keys [context], :or {context (clojure.core/deref global-ctx*)}})</code></div><div class="doc"><div class="markdown"><p>Run cljobq database migrations to ensure the database schema is set up and up-to-date.</p>
<p>Options:</p>
<ul>
  <li><code>:context</code> cljobq context created via <code>cljobq.core/make-context</code>. If not  specified, the implicit <code>cljobq.core/global-ctx*</code> atom set  using <code>cljobq.core/set-context!</code> is used instead.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">(cljobq.core/db-migrate!)
</code></pre></div></div></div><div class="public anchor" id="var-delete-job"><h3>delete-job</h3><div class="usage"><code>(delete-job {:keys [context queue job-name], :or {context (clojure.core/deref global-ctx*)}})</code></div><div class="doc"><div class="markdown"><p>Delete a specific job <code>job-name</code> from the specified queue. Deleting a job by name only really makes sense for recurring jobs. Returns the number of jobs deleted.</p>
<p>Options:</p>
<ul>
  <li><code>:context</code> cljobq context created via <code>cljobq.core/make-context</code>. If not  specified, the implicit <code>cljobq.core/global-ctx*</code> atom set  using <code>cljobq.core/set-context!</code> is used instead.</li>
  <li><code>:job-name</code> The name of the job to delete. Required.</li>
  <li><code>:queue</code> The name of the queue to delete the job from. Required.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">(cljobq.core/delete-job {:queue "math", :job-name "algebra-on-wednesdays"})
</code></pre></div></div></div><div class="public anchor" id="var-delete-queue-jobs"><h3>delete-queue-jobs</h3><div class="usage"><code>(delete-queue-jobs {:keys [context queue], :or {context (clojure.core/deref global-ctx*)}})</code></div><div class="doc"><div class="markdown"><p>Delete all jobs from the specified queue. Returns the number of jobs deleted.</p>
<p>Options:</p>
<ul>
  <li><code>:context</code> cljobq context created via <code>cljobq.core/make-context</code>. If not  specified, the implicit <code>cljobq.core/global-ctx*</code> atom set  using <code>cljobq.core/set-context!</code> is used instead.</li>
  <li><code>:queue</code> The name of the queue. Required.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">(cljobq.core/delete-queue-jobs {:queue "math"})
</code></pre></div></div></div><div class="public anchor" id="var-enqueue"><h3>enqueue</h3><div class="usage"><code>(enqueue {:keys [context queue job-name run-at interval actor args], :or {context (clojure.core/deref global-ctx*), job-name (uuid/v1), run-at nil, interval nil, args []}})</code></div><div class="doc"><div class="markdown"><p>Enqueue a job based on a job description with an optionally specfied explicit <code>context</code>. If a job with the given <code>job-name</code> for the specified <code>queue</code> already exists, the existing job will be updated instead. If no <code>job-name</code> is given, a uuid-based name will be assigned automatically. An <code>interval</code> string (unix cron format) can be specified to create a recurring job. Errors in the interval specification cause an exception to be thrown. Returns the newly inserted job.</p>
<p>Options:</p>
<ul>
  <li><code>:context</code> cljobq context created via <code>cljobq.core/make-context</code>. If not  specified, the implicit <code>cljobq.core/global-ctx*</code> atom set  using <code>cljobq.core/set-context!</code> is used instead.</li>
  <li><code>:job-name</code> A name for the job. A job name is unique within a queue. If  not specified, a UUID-based random name will be used instead.</li>
  <li><code>:queue</code> A queue name to enqueue the job to. Required.</li>
  <li><code>:actor</code> A var-quoted function to run as part of this job. Required.</li>
  <li><code>:args</code> A vector of arguments to pass to the job function.</li>
  <li><code>:interval</code> A string-based UNIX cron expression defining the interval  at which to run a job. If specified, a recurring job is  created. If omitted or nil, the job will only run once.</li>
  <li><code>:run-at</code> The date/time at which to run the job. If omitted, the job  will be scheduled to run immediately if it is a one-off job,  or at the next recurrence if an <code>interval</code> was specified.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">(cljobq.core/enqueue
  {:actor #'*-and-log
   :args [9 6]
   :queue "math"})
</code></pre>
<p>Example return value:</p>
<pre><code class="clojure">{:args [9 6]
 :job-name "10189f80-81ab-11e8-9e30-698897b5b41d"
 :last-error nil
 :queue "math"
 :status "pending"
 :id 18
 :picked-at nil
 :interval nil
 :created-at #inst "2018-07-07T06:00:34.430781000-00:00"
 :run-at #inst "2018-07-07T06:00:34.424000000-00:00"
 :attempt 0
 :related-job-id nil
 :actor "user/*-and-log"}
</code></pre></div></div></div><div class="public anchor" id="var-global-ctx*"><h3>global-ctx*</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-list-failed-jobs"><h3>list-failed-jobs</h3><div class="usage"><code>(list-failed-jobs)</code><code>(list-failed-jobs {:keys [context queue], :or {context (clojure.core/deref global-ctx*), queue nil}})</code></div><div class="doc"><div class="markdown"><p>List all failed jobs. If <code>queue</code> is specified, only jobs for that queue will be shown.</p>
<p>Options:</p>
<ul>
  <li><code>:context</code> cljobq context created via <code>cljobq.core/make-context</code>. If not  specified, the implicit <code>cljobq.core/global-ctx*</code> atom set  using <code>cljobq.core/set-context!</code> is used instead.</li>
  <li><code>:queue</code> The name of the queue. If omitted, jobs from all queues will  be shown.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">(cljobq.core/list-failed-jobs {:queue "queue-c"})
</code></pre>
<p>Example return value:</p>
<pre><code class="clojure">({:args [14 :e]
  :job-name "929238f0-7e2b-11e8-9580-698897b5b41d"
  :last-error "Error from actor `user/*-and-log` payload `[14 :e]`: clojure.lang.Keyword cannot be cast to java.lang.Number\nclojure.lang.Numbers.multiply(Numbers.java:148)\nuser$_STAR__and_log.invokeStatic(form-init6140559550272751977.clj:2)\nuser$_STAR__and_log.invoke(form-init6140559550272751977.clj:1) ..."
  :queue "queue-c"
  :status nil
  :id 12
  :picked-at #inst "2018-07-04T20:43:12.000747000-00:00"
  :interval nil
  :created-at #inst "2018-07-02T19:10:24.264601000-00:00"
  :run-at nil
  :attempt 5
  :related-job-id nil
  :actor "user/*-and-log"})
</code></pre></div></div></div><div class="public anchor" id="var-list-jobs"><h3>list-jobs</h3><div class="usage"><code>(list-jobs)</code><code>(list-jobs {:keys [context queue], :or {context (clojure.core/deref global-ctx*), queue nil}})</code></div><div class="doc"><div class="markdown"><p>List all non-failed jobs. If <code>queue</code> is specified, only jobs for that queue will be shown.</p>
<p>Options:</p>
<ul>
  <li><code>:context</code> cljobq context created via <code>cljobq.core/make-context</code>. If not  specified, the implicit <code>cljobq.core/global-ctx*</code> atom set  using <code>cljobq.core/set-context!</code> is used instead.</li>
  <li><code>:queue</code> The name of the queue. If omitted, jobs from all queues will  be shown.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">(cljobq.core/list-jobs)
</code></pre>
<p>Example return value:</p>
<pre><code class="clojure">({:args [9 6]
  :job-name "10189f80-81ab-11e8-9e30-698897b5b41d"
  :last-error nil
  :queue "math"
  :status "pending"
  :id 18
  :picked-at nil
  :interval nil
  :created-at #inst "2018-07-07T06:00:34.430781000-00:00"
  :run-at #inst "2018-07-07T06:00:34.424000000-00:00"
  :attempt 0
  :related-job-id nil
  :actor "user/*-and-log"}
 {:args [:a 81]
  :job-name "regular-math-err"
  :last-error nil
  :queue "queue-c"
  :status "scheduled"
  :id 22
  :picked-at nil
  :interval "15 23 * * *"
  :created-at #inst "2018-07-07T06:56:35.294888000-00:00"
  :run-at #inst "2018-07-07T22:15:00.000000000-00:00"
  :attempt 0
  :related-job-id nil
  :actor "user/*-and-log"})
</code></pre></div></div></div><div class="public anchor" id="var-list-recurring-jobs"><h3>list-recurring-jobs</h3><div class="usage"><code>(list-recurring-jobs)</code><code>(list-recurring-jobs {:keys [context queue], :or {context (clojure.core/deref global-ctx*), queue nil}})</code></div><div class="doc"><div class="markdown"><p>List all recurring jobs. If <code>queue</code> is specified, only jobs for that queue will be shown.</p>
<p>Options:</p>
<ul>
  <li><code>:context</code> cljobq context created via <code>cljobq.core/make-context</code>. If not  specified, the implicit <code>cljobq.core/global-ctx*</code> atom set  using <code>cljobq.core/set-context!</code> is used instead.</li>
  <li><code>:queue</code> The name of the queue. If omitted, jobs from all queues will  be shown.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">(cljobq.core/list-recurring-jobs {:queue "math"})
</code></pre>
<p>Example return value:</p>
<pre><code class="clojure">({:args [:a 81]
  :job-name "regular-math-err"
  :last-error nil
  :queue "queue-c"
  :status "scheduled"
  :id 22
  :picked-at nil
  :interval "15 23 * * *"
  :created-at #inst "2018-07-07T06:56:35.294888000-00:00"
  :run-at #inst "2018-07-07T22:15:00.000000000-00:00"
  :attempt 0
  :related-job-id nil
  :actor "user/*-and-log"})
</code></pre></div></div></div><div class="public anchor" id="var-make-context"><h3>make-context</h3><div class="usage"><code>(make-context {:keys [db default-timeout default-max-timeout default-max-attempts default-num-threads], :or {default-timeout 1800, default-max-timeout (* default-timeout 10), default-num-threads 1, default-max-attempts 3}, :as context})</code></div><div class="doc"><div class="markdown"><p>Return a new cljobq context based on the config hash passed in. cljobq does not use connection pooling internally, however, connection pooling can be enabled by using a db-spec with a data source set using hikari-cp or c3p0.</p>
<p>All options except for <code>:db</code> can be overriden per queue in the queue-defs passed to <code>cljobq.core/start</code>.</p>
<p>Options:</p>
<ul>
  <li><code>:db</code> A <code>clojure.java.jdbc</code> db-spec map. Required.</li>
  <li><code>:default-timeout</code> The default job timeout, in seconds. Defaults to  1800 seconds.</li>
  <li><code>:default-max-timeout</code> The default maximum job timeout, including any  backoff. Defaults to 10 times the default timeout.</li>
  <li><code>:default-max-attempts</code> The default maximum number of attempts/retries to  try and run a job for before marking it as failed.  Defaults to 3.</li>
  <li><code>:default-num-threads</code> The default number of worker threads for a queue.  Defaults to 1.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">(def jobq-context
  (cljobq.core/make-context
    {:db {:connection-uri "jdbc:postgresql://localhost:5432/jobqtest?user=test&amp;password=test"}
     :default-timeout 180}))
</code></pre></div></div></div><div class="public anchor" id="var-set-context.21"><h3>set-context!</h3><div class="usage"><code>(set-context! v)</code></div><div class="doc"><div class="markdown"><p>Set the global context <code>cljobq.core/global-ctx*</code> based on the passed in config <code>v</code>. See <code>cljobq.core/make-context</code> for more information on the configuration options.</p>
<p>The global context serves as an implicit context to all other functions in the absence of an explicit context.</p>
<p>Example:</p>
<pre><code class="clojure">(cljobq.core/set-context!
  {:db {:connection-uri "jdbc:postgresql://localhost:5432/jobqtest?user=test&amp;password=test"}
   :default-timeout 180})
</code></pre></div></div></div><div class="public anchor" id="var-start"><h3>start</h3><div class="usage"><code>(start {:keys [context queues], :or {context (clojure.core/deref global-ctx*)}})</code></div><div class="doc"><div class="markdown"><p>Given a set of queue definitions in <code>queues</code>, start the worker threads for each of the defined queues and start processing jobs. Returns a <code>run-info</code> which can be used to stop the threads (see <code>cljobq.core/stop</code> for more information.</p>
<p>Options:</p>
<ul>
  <li><code>:context</code> cljobq context created via <code>cljobq.core/make-context</code>. If not  specified, the implicit <code>cljobq.core/global-ctx*</code> atom set  using <code>cljobq.core/set-context!</code> is used instead.</li>
  <li><code>:queues</code> A map of queue-name -&gt; queue-def. A queue def can an empty  map, in which case the defaults of the <code>context</code> will be used  for all options.</li>
</ul>
<p>Each queue-def is a map with the following options (defaults are taken from the context - see <code>cljobq.core/make-context</code>):</p>
<ul>
  <li><code>:num-threads</code> The number of worker threads to start for this queue.</li>
  <li><code>:max-attempts</code> The maximum number of attempts/retries to try and run  a job on this queue for before marking it as failed.</li>
  <li><code>:timeout</code> The job timeout, in seconds.</li>
  <li><code>:max-timeout</code> The maximum job timeout, including any backoff.</li>
  <li><code>:backoff-factor</code> The backoff factor to use when calculating when to retry  a job. Calculated as: <code>random() * timeout + min(max-timeout, timeout * backoff-factor ^ attempt-number)</code>. A <code>backoff-factor</code> of 1 defines a constant backoff, whilst a factor greater than 1 defines an exponential backoff.</li>
  <li><code>:poll-interval</code> The number of seconds the queue’s workers will sleep  for if no job is ready to run.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">(def jobq-runinfo
  (cljobq.core/start
    {:queues
     {:default
      {}
      :math
      {:num-threads 4
       :max-attempts 1
       :poll-interval 5}
      :email
      {:num-threads 2
       :timeout 600
       :max-timeout 14400
       :backoff-factor 1.9}}}))
</code></pre></div></div></div><div class="public anchor" id="var-stop"><h3>stop</h3><div class="usage"><code>(stop)</code><code>(stop run-info-or-ctx)</code></div><div class="doc"><div class="markdown"><p>Stop all worker threads. Can be passed either a <code>run-info</code> returned by <code>cljobq.core/start</code> or a context. If passed a context, only the threads started by the last call to <code>cljobq.core/start</code> with that context will be stopped.</p>
<p>Example:</p>
<pre><code class="clojure">(cljobq.core/stop jobq-runinfo)
</code></pre></div></div></div></div></body></html>